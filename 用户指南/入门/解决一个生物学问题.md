---
description: >-
  该页面翻译自：https://new.rosettacommons.org/docs/latest/getting_started/Solving-a-Biological-Problem
---

# 🧑🦰 解决一个生物学问题

Rosetta可以解决许多生物学问题。这些问题往往源于一个中心思想，即序列决定结构，结构决定功能。例如，Rosetta最初用于蛋白质结构的从头预测（序列->结构），而当前的应用程序更为广泛（像酶设计）。

一般来说（对于大多数生物学问题），面临着双重计算挑战。首先，我们能否对问题的解决方案所在的空间进行充分的采样？其次，如果我们已经对它采样了，我们能否识别出来解决方案。在决定对您的问题采用那种协议，生成多少个模型以及使用哪种评分函数时，应该牢记这一点。

如果此页面所描述的并不像您的问题，那可能是您尚未[明确您所要解决的问题](https://new.rosettacommons.org/docs/latest/getting\_started/Determining-what-a-problem-is)，又或者我们无法解决。如果您是从一个特定自由度的采样角度考虑您的问题，请看[这一页](https://new.rosettacommons.org/docs/latest/getting\_started/I-want-to-do-x)。

| 目录 |
| -- |
|    |
|    |
|    |

## 生物学问题的类型

### 蛋白质结构预测

下面要回答的一般问题是：给定一条蛋白序列，我们能预测蛋白质的结构吗？有两种仅从蛋白序列预测蛋白结构的方法：从头建模（_de novo_）和比较（comparative）/同源建模（homology modeling）。还有其他更专业的方法用于特定的任务，例如抗体同源建模（antibody homology modeling）、对称同源寡聚体建模（symmetric homooligomer modeling）和膜蛋白建模（membrane protein modeling）。

#### 从头建模（De Novo Modeling）

在对找不到同源模板【译者注：在已知结构的蛋白序列中未找到同源序列，即序列相似性很低。这里请注意请勿混淆同源和相似的概念，同源只有“有”和“无”的概念，而没有大小之分；序列的相似性可以有大小高低之别】的蛋白进行建模时，从头预测的算法往往非常有用【译者注：因为同源建模在这种情况下已然无法使用】。在从头预测的算法中，蛋白序列从拓展构象开始，并从n-mer片段库采样得到的phi/psi角的变化进行“折叠”（floded）。当对小的（小于100个残基）球状蛋白进行建模时，从头预测是准确的。

请参阅： [Ab initio Modeling Tutorial](https://www.rosettacommons.org/demos/latest/tutorials/denovo\_structure\_prediction/Denovo\_structure\_prediction), [Tutorial on protein folding using the Broker](https://www.rosettacommons.org/demos/latest/tutorials/advanced\_denovo\_structure\_prediction/folding\_tutorial) 和 [Ab initio](https://new.rosettacommons.org/docs/latest/application\_documentation/structure\_prediction/abinitio-relax)

#### 比较/同源建模（Comparative/Homology Modeling)

另一方面，当目标序列（感兴趣的蛋白序列）与结构已经确定的蛋白质具有高度的相似性（大于50%）时，比较建模往往会比较成功。通常情况下，感兴趣的蛋白序列被匹配到已知的蛋白结构上【译者注：译者浅见：比较建模的本质就是“抄”，未知序列“抄”已知结构上对应位置的三维坐标（二面角）】，低相似性区域通过loop closure（见下文）或其他技术进行建模。

请参阅：[Comparative Modeling Tutorial](https://www.rosettacommons.org/demos/latest/tutorials/rosetta\_cm/rosetta\_cm\_tutorial)、[Comparative Modeling](https://new.rosettacommons.org/docs/latest/application\_documentation/structure\_prediction/minirosetta-comparative-modeling)（可能已过时）和[Comparative Modeling via RosettaScripts](http://www.ncbi.nlm.nih.gov/pubmed/24035711)（使用 RosettaScripts）了解更多信息。

### 蛋白-蛋白对接

Rosetta要询问的另一个一般问题是：给定蛋白A和蛋白B，我能否生成一个可信的蛋白-蛋白相互作用模型？当蛋白A，蛋白B或者两者结构都未知时，这个问题可以与蛋白结构预测混为一谈。蛋白质灵活性可以通过增加自由度在蛋白质对接中发挥作用。例如，结合态和非结合态之间的高RMSD使得从非结合态预测结合态变得困难。另一方面，生化信息可以在对接过程中作为评分函数中的约束（见下文）条件来实现以提高模型准确性。

一般来说，对接分三种：全局对接（global）、局部对接（local）和局部优化（local refine）。这些都是通过[对接协议](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/docking-protocol)运行的，但是标志不同。查看有关蛋白-蛋白对接的[教程](https://www.rosettacommons.org/demos/latest/tutorials/Protein-Protein-Docking/Protein-Protein-Docking)。

* **全局对接**需要两个伙伴【译者注：原文partners，意思大概是参与对接的两个主体，例如这里做蛋白A和蛋白B对接，那么蛋白A和B就称为partners】的随机初始放置，具有(相对)大刚体平移的低分辨率质心相位，以及具有较小扰动和侧链重新填充（repacking）/最小化（minimization）的高分辨率全原子相位。
* **局部对接**与全局对接相同，只是伙伴的初始位置不是随机的，从而确保对初始配置的相互作用进行采样。
* **局部优化对接**仅使用高分辨率的全原子相位（phase）。

有关如何运行对接模拟的更多信息， 请参阅[对接协议。](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/docking-protocol)**注意：**在对接之前应[预先填充](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/docking-prepack-protocol)侧链，来全面减少侧链的能量，因为对接只填充界面上的侧链。【译者注：这里的“预填充”，我更愿意描述为“预处理”】

#### 对接两个已知结构的伙伴

在这种情况下，已经为两个相互作用的伙伴确定了（近似）原子级别的分辨率结构【译者注：分辨率较低的实验解析的蛋白质结构。在alphafold2时代的背景下，也许一些高质量的蛋白模型也能满足“原子分辨率结构”的要求】。结构应以标准方式准备对接（请参阅[准备结构](https://new.rosettacommons.org/docs/latest/rosetta\_basics/preparation/preparing-structures)，[预填充](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/docking-prepack-protocol)）。然后，[对接协议](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/docking-protocol)将以最少的能量搜索复杂的结构。

对接可以模拟以下几种蛋白-蛋白相互作用的生物物理模型：

**根据锁与钥匙模型对接 (Lock and Key Model)**

锁与钥匙模型假定蛋白质以刚性方式相互作用，两个蛋白质必须具有形状互补性【译者注：两个蛋白相互作用所“接触”的部分形状需要是互补的】才能相互作用。假设两个蛋白伙伴在结合时不会有骨架运动，可以用刚性骨架对接（rigid-backbone docking）的方式来解决这个问题。

**根据构象选择模型对接(Conformer Selection Model)**

在构象选择模型下，蛋白质被视为构象的统计组合，包括每个伙伴的结合和非结合构象。为了形成结合的复合体，每个伙伴的结合构象必须相互偶遇。为了对这种行为进行计算建模，可以使用[relax protocol](https://new.rosettacommons.org/docs/latest/application\_documentation/structure\_prediction/relax)为伙伴（或两者）生成一个结构系综（ensemble）。为了对接结果的合理性，一个结构系综与初始模型的RMSD不应该超过1埃。这些结构系综可以在对接协议（docking protocol）中进行采样。

**根据诱导契合模型对接(Induced Fit Model)**

诱导契合模型为前两种模型提供了一个替代方案。诱导契合认为，在相遇时，蛋白质会相互影响。这是在对接协议的高分辨率阶段，通过最小化骨架自由度（除了典型的最小化侧链自由度）来计算建模的。截至2015年6月9号，有一个-`bb_min_res`标签，可以用来指定在最小化过程中具有骨架自由度的残基，但是对接过程中的骨架最小化还没有被彻底测试。

**根据构象选择和诱导契合模型对接**

这是前两个模型的组合。在计算上，结构系综和骨架最小化都得到了实现。

#### 对接一个结构未知一个结构已知的两个伙伴

这个问题稍微复杂一些，也更困难一些。由于增加了对一个蛋白进行同源或从头建模的必要性【译者注：既然一个结构未知，那么自然要想办法对结构进行建模】，结果的准确性较低。最好的方法是为未知结构的蛋白输入一个系综模型。有一点需要注意，因为系综对接（ensemble docking）根据Metropolis准则交换模型，所以系综模型不能有太多的多样性，否则将完全没有用处。

**对接两个未知结构的伙伴**

这样做有道理，但是不建议这样做。由于需要大量的抽样来(A)精确建模一个伙伴，(B)准确建模另一个伙伴，以及(C)准确建模两个伙伴之间的相互作用，所以成功的可能性极低。

#### 对接同源寡聚物

[对称对接](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/sym-dock)对于根据[对称文件](https://new.rosettacommons.org/docs/latest/application\_documentation/utilities/make-symmdef-file-denovo)中定义的特定对称性组装多个亚单位很有用。

### 蛋白质-肽对接

蛋白质-肽对接对于确定受体背景下短而灵活的的肽的结构非常有用。Rosetta的[蛋白质-肽对接](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/flex-pep-dock)方法最好从靠近肽结合位点的近似模型开始，骨架的RMSD在5埃以内是较为理想的。因为，要同时对肽的构象和蛋白质表面所有可能的结合位点进行取样，一般来说是不可行的。Rosetta也有能力对类似肽的分子（peptidomimetic）的构象进行取样，如oligooxopiperazines, hydrogen bond surrogate helices, stapled peptides, peptoids, beta peptides等。

### 蛋白-配体对接

我可以预测一个小分子如何与我的蛋白质相互作用吗？与蛋白质-蛋白质对接一样，你的初始结构越好，就越有可能产生一个准确的模型（见上文）。[RosettaLigand](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/ligand-dock)或[RosettaLigand via RosettaScripts](http://dx.doi.org/10.1007%2F978-1-61779-465-0\_10)可以用来预测蛋白质-配体的相互作用。RosettaLigand通过可执行程序运行（目前已经过时）。最好是通过RosettaScripts对接配体。另一种方法是使用[Docking Approach using Ray Casting (DARC)](https://new.rosettacommons.org/docs/latest/application\_documentation/docking/DARC)方法。与RosettaLigand不同的是，DARC通过平移和旋转来探索蛋白质和配体之间的相互作用（如果这是错的，请纠正我），评估配体对蛋白质表面口的形状互补性。

### 蛋白质设计

蛋白质结构预测旨在识别空间中的低能量结构，而蛋白质设计则旨在识别序列空间中的氨基酸特性。蛋白质设计可用于研究序列如何赋予结构（即预测特定折叠的氨基酸序列）或结构如何赋予功能（即预测特定功能的氨基酸序列）。由于这些挑战的广泛性，协议要么是特定的，要么是使用Rosetta脚本接口之一定制生成的。从广义上来说，只要重新填充（repacked）侧链，就可以使用resfiles和flags来进行蛋白质设计。

### 蛋白质重新设计(Protein Redesign)

人们可以设想一个简单的设计问题，他们寻求稳定一个已知的蛋白结构。一个合理的假设是，蛋白质的折叠不会有太大变化【译者注：目的是追求结构的稳定，保留原有的功能，因此不能使得蛋白的折叠发生太大的变化而影响功能？？？】。因此这个问题是通过[固定骨架设计](https://new.rosettacommons.org/docs/latest/application\_documentation/design/fixbb)来解决的，其中侧链氨基酸的身份被采样，以确定那些在当前骨架上能量最小的氨基酸。此外，如果设计是产生一个有利于疏水残基的氨基酸序列，那么[在运行骨架设计时可以考虑疏水表面斑块](https://new.rosettacommons.org/docs/latest/application\_documentation/design/fixbb-with-hpatch)（surface patches）【译者注：疏水表面斑块的意思如何理解，我觉得就是强调如果我们想设计一个倾向于疏水的蛋白质，那么蛋白质表面应该是倾向于疏水的残基】。然而，新的打分函数限制了这个问题。

其他有趣的设计问题可能包括：

* 扫描[稳定点突变](https://new.rosettacommons.org/docs/latest/application\_documentation/design/pmut-scan-parallel)
* 具有[序列容忍度](https://new.rosettacommons.org/docs/latest/application\_documentation/design/sequence-tolerance)的特异性预测和文库设计
* 在不同背景下的不同功能的[多肽设计](https://new.rosettacommons.org/docs/latest/application\_documentation/design/mpi-msd)
* RosettaRemodel是一个通用的框架，用于灵活的骨架设计（[更多的RosettaRemodel文档](https://new.rosettacommons.org/docs/latest/application\_documentation/design/Remodel)）
* 利用[表面电荷](https://new.rosettacommons.org/docs/latest/application\_documentation/design/supercharge)提高溶解度和折叠的可逆性
* 通过空腔识别和填充改善疏水性填充

### 蛋白质界面设计（Protein Interface Design）

[锚定设计](https://new.rosettacommons.org/docs/latest/application\_documentation/design/anchored-design) [肽设计](https://new.rosettacommons.org/docs/latest/application\_documentation/design/pepspec)

### 酶设计（nzyme Design）

[酶设计](https://new.rosettacommons.org/docs/latest/application\_documentation/design/enzyme-design)

### 蛋白质Loop建模

Loop建模是蛋白质结构预测和设计的一个复杂和核心的要素。有两个典型的生物学问题：

* 为晶体结构中的低密度区域构建Loop模型
* 在同源建模中相似性较低且没有二级结构的区域构建Loop模型，有许多工具可以完成这个任务。

关于Rosetta中Loop建模的概述，[请参阅此处](https://new.rosettacommons.org/docs/latest/application\_documentation/structure\_prediction/loop\_modeling/loopmodel)。

#### 在低电子密度区域建模Loop

对于晶体学数据的明确细化，[请参阅此处](https://new.rosettacommons.org/docs/latest/application\_documentation/analysis/density-map-scoring)。

<mark style="color:red;">loops from density</mark>是一个脚本，它可以接受拟合不好的电子数据和一个提示你愿意重建多少个姿势【译者注：姿势->多种不同构象的loop】的截止值，并生成用于loop建模的“loops”输入文件。

对于现有蛋白质结构上缺失loop的建模，你可以使用以下部分中的任何方法。
